Instructions for enabling new catalog formats to be read
--------------------------------------------------------

Galaxy catalog types are implemented as subclasses of the GalaxyCatalog class,
which is defined in GalaxyCatalogInterface.py. To implement a new type, create
a new file implementing your class called YourGalaxyCatalog.py (replace
"Your" with some unique identifier). It's important that you follow this
naming convention, as it allows the generic catalog interface to automatically
find and import your class when the validation framework is run.

Galaxy catalog classes must be subclasses of GalaxyCatalog. So for example
you would write

from GalaxyCatalogInterface import GalaxyCatalog
class YourGalaxyCatalog(GalaxyCatalog):

at the top of YourGalaxyCatalog.py (again changing "Your" to something more
meaningful). At a minimum, your catalog class needs to implement the following
methods:

  __init__       The class constructor. Takes one optional argument, a filename,
                 with default value None. This method should set up internal
                 data structures needed for the class _without reading the file_
                 and then return the result of invoking the parent class's
                 __init__ method, passing the filename argument through. So for
                 example:

                 class YourGalaxyCatalog(GalaxyCatalog):
                     def __init__(self, fn=None):
                         <do initialization stuff>
                         return GalaxyCatalog.__init__(self, fn)

  load           The method used to read the catalog into memory. Takes a
                 non-optional filename argument and returns self. For example:
 
                     def load(self, fn):
                         <read file fn>
                         return self

These are the minimum required methods. They allow you to initialize and read
in your catalog but not do anything with it. To make data available from your
catalog to calling programs, you must either implement your own versions of the
following methods or else set up (in __init__) the data structures needed to
work with the generic GalaxyCatalog versions of the methods. The additional
methods are:

  is_valid       Given the name of a file, return True if it is a catalog of
                 your type or False if not. The generic mechanism relies upon
                 filename extensions. If you want to use this approach, simply
                 set self.type_ext equal to a string containing your catalog's
                 filename extension in __init__.

  get_cosmology  Takes no arguments (other than self), and returns an Astropy
                 cosmology object describing the cosmology used to construct
                 your catalog. If you wish to use the generic interface, have
                 your load method import astropy.cosmology and set the variable
                 self.cosmology equal to an astropy.cosmology object with the
                 appropriate cosmological parameter values (see Astropy
                 documentation for details). The generic get_cosmology merely
                 returns self.cosmology.

  get_sky_area   Takes no arguments (other than self), and returns an Astropy
                 Quantity object containing the sky area of the catalog. If you
                 wish to use the generic interface, have your load method set
                 self.sky_area equal to an astropy.units.Quantity object with
                 the appropriate value. The default implementation sets this to
                 4*pi steradians (all sky).

  get_quantities Takes two arguments (other than self), ids and filters. ids is
                 either a string or a list of strings indicating the names of
                 galaxy properties being requested. If it is a string, the
                 routine should return a single NumPy array containing the
                 value of the quantity for each galaxy. If ids is a list, the
                 routine should return a list of NumPy arrays, one for each
                 requested property.

                 The filters argument should be a dictionary whose keys are
                 the names of filter constraints to apply and whose values are
                 the corresponding constraints. For example, { 'zlo': 0.5 }
                 means to return values for galaxies whose redshifts are at
                 least 0.5. If no filters are needed, pass {} for the filters
                 argument.

                 The generic implementation of get_quantities relies on two
                 dictionary attributes of the class, self.quantities and
                 self.filters. The first is a dictionary whose keys are the
                 string names of galaxy properties that can be requested from
                 the catalog and whose values are the methods used to return
                 the quantities. These methods should take two arguments:
                 the string name of the quantity and a dictionary containing
                 the filters to be applied. They should return NumPy arrays
                 (in the future we may ask for Astropy Quantity arrays to
                 help with unit conversions).

                 The self.filters dictionary is used by the generic
                 implementation to represent filters that are supported by your
                 galaxy catalog class. It should have as keys the string names
                 of filters. At present the values are used only to determine
                 if the corresponding filters are supported (True or False).
                 You may use them in another way; the generic implementation
                 merely checks to see if the corresponding values are True and
                 then passes the filter dictionary supplied to get_quantities
                 through to the appropriate quantity getter method.

                 Certain filters and quantities should be supported by all
                 catalogs. The names for these, and comments giving guidance
                 regarding units to be returned etc., are listed in the generic
                 GalaxyCatalog class definition in GalaxyCatalogInterface.py.

  get_supp_filters
  get_supp_quantities
                 These methods return lists, respectively, of filter and
                 quantity names supported by the catalog class. If you override
                 the generic mechanism you should provide replacements for
                 these methods.

An example implementation of a galaxy catalog class is given for the Argonne
catalog format in ANLGalaxyCatalog.py. This class demonstrates the use of the
above generic mechanisms together with a filter implementation. In addition,
it demonstrates how generic local quantity getter methods can be implemented.
It distinguishes between 'stored' quantities, which are actually present in the
catalog file, and 'derived' quantities, which are computed from 'stored'
quantities using a simple function call.

Initially we are targeting the stellar mass function as a test. To work with
this test, your catalog must support the 'zlo' (minimum redshift) and 'zhi'
(maximum redshift) filters and the 'stellar_mass' quantity. Below is an example
of the type of usage that should be possible with your catalog.

from GalaxyCatalogInterface import loadCatalog
import numpy as np
import astropy.units as u

zlo = 0.05
zhi = 0.15
Nbins = 10

gc = loadCatalog("your_catalog_file.ext")
if gc:
    masses = gc.get_quantities("stellar_mass", {'zlo': zlo, 'zhi': zhi})
    # masses now contains an array of stellar masses for galaxies with
    # redshifts between zlo and zhi, in units of Msun.
    log_masses = np.log10(masses)
    mhist, mbins = np.histogram(logm, Nbins)
    bin_width = mbins[1:] - mbins[:Nbins]
    vol_zhi = gc.get_cosmology().comoving_volume(zhi)
    vol_zlo = gc.get_cosmology().comoving_volume(zlo)
    # these are both Astropy Quantity objects with units of Mpc**3
    delta_vol = float((vol_zhi-vol_zlo) / u.Mpc**3)
    area_factor = float(gc.get_sky_area() / (4.*np.pi*u.sr))
    mhist = mhist / bin_width / (area_factor*delta_vol)
    # mhist should now contain # galaxies per Mpc**3 per dex.

Finally, once you are happy with YourGalaxyCatalog.py, place it into the
catalog/functions subdirectory of the descqa git repository. It will then
automatically be found and imported by the loadCatalog convenience function
defined in GalaxyCatalogInterface.py.
